#lang racket

(require "parser.rkt") ;; provides parse
(require "defaults.rkt") ;; provides base-js, default-macros and the macro struct

(define (compile filename)
  (let* [[syntax-tree
          (parse filename (open-input-file filename))]
         [generated-code
          (cross-compile (operators->functions (syntax->datum syntax-tree)) default-macros)]]
    (string-append base-js generated-code)))

(define (make-macro-helpers syntax-tree)
  ;; extract macro definitions, compile all those that don't depend on other user-defined
  ;; macros to js that we'll invoke in an external file when applying those macros
  ;; reapply to add on the macros that depend on other macros
  #f)

(define (cross-compile syntax-tree macros)
  (case (first syntax-tree)
    [(block) (string-join (map (λ (e) (cross-compile e macros)) (rest syntax-tree)) ";")]
    [(function-application)
     (if (and (member (first (second syntax-tree)) '(variable operator))
              (hash-has-key? macros (second (second syntax-tree))))
         (cross-compile (apply-macro syntax-tree (hash-ref macros (second (second syntax-tree)))) macros)
         (format "autocurry(~a,[~a])" (cross-compile (second syntax-tree) macros)
                 (string-join (map (λ (e) (cross-compile e macros)) (drop syntax-tree 2)) ",")))]
    [(variable number) (bytes->string/utf-8 (second syntax-tree))]
    [(operator) (second syntax-tree)]
    [(string) (format "\"~a\"" (second syntax-tree))]
    [(list) (format "[~a]" (string-join (map (λ (e) (cross-compile e macros))
                                             (rest syntax-tree)) ","))]
    [(quoted-syntax) (cross-compile (ash-quote (second syntax-tree)) macros)]
    [(quasiquoted-syntax) (cross-compile (ash-quasiquote (second syntax-tree)) macros)]
    [(js-literal) (format "~a" (second syntax-tree))]
    ;; these are generated by builtin macros, not by the parser
    [(defvar) (format "var ~a = ~a" (cross-compile (second syntax-tree) macros)
                      (cross-compile (third syntax-tree) macros))]
    [(defun) (format "function ~a(~a){~a}"
                     (second (second (second syntax-tree)))
                     (string-join (map (λ (e) (cross-compile e macros)) (drop (second syntax-tree) 2)) ",")
                     (cross-compile (third syntax-tree) macros))]
    [(if) (apply format (cons "((~a)?(~a):(~a))" (map (λ (e) (cross-compile e macros)) (rest syntax-tree))))]
    [else (format "~a" syntax-tree)]));(error "unrecognised element in AST")]))

(define (apply-macro syntax-tree mac)
  ;; if macro is a builtin, run it.
  ;; if it's not, invoke the external compiled macro helper we made.
  (if (macro-builtin? mac)
      (if (= (macro-arity mac) (- (length syntax-tree) 2))
          ((macro-proc mac) syntax-tree)
          (error "macro arity error"))
      (error "user-defined macros not yet supported")))

(define (operators->functions syntax-tree)
  (map (λ (expr)
         (cond
           [(not (list? expr)) expr]
           [(equal? (first expr) 'operator-application)
            (operators->functions
             `(function-application ,(third expr) ,(second expr) ,(fourth expr)))]
           [(equal? (first expr) 'operator)
            (list 'operator (operator-name (second expr)))]
           [else (operators->functions expr)]))
       syntax-tree))

;;;;;;;;;;;;
;; quoting
;;;;;

(define (ash-quote expr)
  (cond
    [(list? expr) (cons 'list (map ash-quote expr))]
    [(symbol? expr) `(variable ,(string->bytes/utf-8 (symbol->string expr)))]
    [(bytes? expr) `(string ,expr)]))

(define (ash-quasiquote expr)
  (cond
    [(list? expr) (if (equal? (first expr) 'unquoted-syntax)
                      (second expr)
                      (cons 'list (map ash-quasiquote expr)))]
    [(symbol? expr) `(variable ,(string->bytes/utf-8 (symbol->string expr)))]
    [(bytes? expr) `(string ,expr)]))

;;;;;;;;;;;;;;;;;;;;;
;; helper functions
;;;;

(define (operator-name op)
  (apply string-append
         (cons "op_"(map
                     (λ (c) (case c
                              [(#\-) "dash"]
                              [(#\+) "plus"]
                              [(#\*) "star"]
                              [(#\/) "slash"]
                              [(#\>) "gt"]
                              [(#\<) "lt"]
                              [(#\=) "eq"]
                              [(#\!) "bang"]
                              [(#\&) "amp"]
                              [(#\|) "pipe"]
                              [(#\%) "pcnt"]
                              [(#\$) "dllr"]
                              [(#\~) "tilde"]
                              [(#\#) "hash"]
                              [(#\?) "qry"]
                              [(#\:) "colon"]
                              [(#\.) "dot"]
                              [(#\^) "caret"]
                              [else (error "unrecognised char in operator name")]))
                     (string->list (bytes->string/utf-8 op))))))

(provide compile)